import time

from dedi_registry.etc.consts import LOGGER
from dedi_registry.etc.utils import ThreadSafeDict
from .cache import ChallengeCache, Cache


class MemoryChallengeCache(ChallengeCache):
    """
    An in-memory implementation of the ChallengeCache for caching challenge data.
    """

    _challenges = ThreadSafeDict()
    _routes = ThreadSafeDict()

    async def save_challenge(self,
                             nonce: str,
                             difficulty: int,
                             ):
        """
        Store a generated challenge in the cache.
        :param nonce: The challenge nonce, generated by challenger
        :param difficulty: The difficulty of the challenge, by how many leading zeros it should have
        """
        LOGGER.debug(
            'Saving challenge to memory cache: nonce=%s, difficulty=%d',
            nonce,
            difficulty
        )

        self._challenges[nonce] = {
            'difficulty': difficulty,
            'timestamp': time.time(),
        }

    async def get_challenge(self,
                            nonce: str,
                            ) -> int | None:
        """
        Retrieve a challenge from the cache.
        :param nonce: The challenge nonce to retrieve
        :return: The difficulty of the challenge if it exists and is not expired, otherwise None
        """
        challenge = self._challenges.get(nonce)

        if challenge:
            if challenge['timestamp'] + 300 > int(time.time()):
                LOGGER.debug(
                    'Challenge found in memory cache: nonce=%s, difficulty=%d',
                    nonce,
                    challenge['difficulty']
                )
                return challenge['difficulty']

            LOGGER.warning(
                'Expired challenge accessed in memory cache: nonce=%s, difficulty=%d',
                nonce,
                challenge['difficulty']
            )

        return None


class MemoryCache(Cache):
    """
    An in-memory implementation of the Cache for storing data in a centralised place.

    This implementation is used for single-process only. DO NOT use this if the application
    is run with multiprocess workers. The implementation is thread-safe.
    """

    @property
    def challenge(self) -> MemoryChallengeCache:
        """
        Return the challenge cache instance.
        :return: An instance of MemoryChallengeCache for managing challenge-related data.
        """
        return MemoryChallengeCache()
